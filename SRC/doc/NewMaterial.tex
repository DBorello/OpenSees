\documentclass[12pt]{article}

\usepackage{headerfooter}
\usepackage{epsfig}
\usepackage{verbatimfiles}
\usepackage{fullpage}

\newcommand{\HRule}{\rule{\linewidth}{.3mm}}

\begin{document}
\bibliographystyle{plain}

\begin{center}
{\bf \Large How to Introduce a New Material into OpenSees}

{\bf Version 1.1} 

{\bf March 6, 2001} 

{\bf Michael Scott and Frank McKenna} 

{\bf PEER, University of California at Berkeley}
\end{center}

%\begin{figure}[htpb]
%\begin{center}
%\leavevmode
%\hbox{%
%\epsfxsize=6.5in
%\epsffile{./Roadmap.eps}}
%\end{center}
%\caption{Material hierarchy}
%\label{main}
%\end{figure}

%\vspace{.2in}
\section{Introduction}
This document shows how to add a new material implementation to OpenSees. The hierarchical
structure of the OpenSees software architecture allows new material models
to be seamlessly added to the framework. By keeping element and material implementations
separate, a new material model can be used in an existing element without modifying
the element implementation, and vice versa. The programming language C++ directly supports
the data encapsulation and run-time binding necessary to achieve this complete separation 
of material from element.

Currently, there are three Material abstractions in OpenSees, each of which can be used 
across a wide range of element implementations:

\begin{enumerate}
\item{\bf UniaxialMaterial} - Provides functionality for all 1d material models, either
stress-strain or force-deformation.
UniaxialMaterial models define the stress-strain response of a truss element, uniaxial 
fiber behavior in a
beam-column section, or the force-deformation response of a zero-length element.
Uniaxial hysteretic response may also be represented with a UniaxialMaterial model.

\item{\bf ContinuumMaterial} - The multi-dimensional generalization of UniaxialMaterial;
provides the stress-strain response at a point in a solid element, or multi-dimensional
fiber behavior in a beam-column section.

\item{\bf ForceDeformation} - Defines the interface for stress resultant models which are
used to describe beam-column section response as well as the constitutive response of more
general zero-length elements, e.g., for isolator bearings.
\end{enumerate}

\noindent Each interface listed above is essentially the same with only small differences.
UniaxialMaterial is a separate interface from ContinuumMaterial since all stress-strain and
force-deformation values 
are scalars for a 1d model. ForceDeformation differs from ContinuumMaterial in its meaning and
physical interpretation, as it
is intended for {\em resultant} models of material behavior.

Rather than show examples of implementing
a model for each interface, only the UniaxialMaterial interface is covered herein. The
basic concepts of adding a material model to OpenSees carry directly over from UniaxialMaterial
to ContinuumMaterial and ForceDeformation.

The remainder of this document is laid out as follows. First, the UniaxialMaterial interface is 
listed and explained. Then, an example UniaxialMaterial
implementation, HardeningMaterial, is presented. Along with the C++ implementation, it is shown how
to add the new model to the TCL model builder used in OpenSees. Finally, a UniaxialMaterial
implementation capable of wrapping FEDEAS uniaxial material models is given as an example
of linking OpenSees with other material libraries.

\section{UniaxialMaterial Interface}
Implementations of the UniaxialMaterial interface may be used in several contexts within
the OpenSees modeling framework. Due to their simplicity, these models can be used for both
stress-strain and force-deformation relationships. It is up to the calling object to interpret
the meaning appropriately.

Listed below is the UniaxialMaterial C++ class interface. UniaxialMaterial is a subclass of
Material, which serves as a means of object identification within the OpenSees framework.
No relevant methods are declared in the Material interface, so it is not shown here. The 
UniaxialMaterial base class
constructor takes a tag and class tag as its arguments, as seen below.
All methods in the UniaxialMaterial interface are public, there are no protected or
private data or methods.
Following the UniaxialMaterial class interface listing, each method in the interface is
described.

{\sf\small
\begin{verbatim}
#include <Material.h>

class Response;
class Information;

class UniaxialMaterial : public Material
{
   public:
      UniaxialMaterial(int tag, int classTag);    
      virtual ~UniaxialMaterial(void);

      virtual int setTrialStrain(double strain, double strainRate = 0.0) = 0;
      virtual double getStrain(void) = 0;
      virtual double getStrainRate(void) {return 0.0;}
      virtual double getStress(void) = 0;
      virtual double getTangent(void) = 0;
      virtual double getDampTangent(void) {return 0.0;}
      virtual double getSecant(void) {return this->getTangent();}

      virtual int commitState(void) = 0;
      virtual int revertToLastCommit(void) = 0;    
      virtual int revertToStart(void) = 0;        

      virtual UniaxialMaterial *getCopy(void) = 0;

      virtual Response *setResponse(char **argv, int argc, Information &matInfo);
      virtual int getResponse(int responseID, Information &matInfo);    

   protected:
    
   private:
};
\end{verbatim}
}

The tag passed to the constructor identifes this UniaxialMaterial
as unique among all other UniaxialMaterial objects, and the class tag is used primarily for
parallel processing and database programming. Class tags are defined in the file classTags.h.
The UniaxialMaterial destructor is declared, but does not do anything as the UniaxialMaterial
base class contains no data.

The method {\em setTrialStrain()} takes one or two arguments, an updated strain
and strain rate. The strain rate is an optional argument, with default value $0.0$. This
method is pure virtual, so it must be implemented in all subclasses of UniaxialMaterial.
The next two methods, {\em getStrain()} and {\em getStrainRate()}, are to return the current
strain and strain rate of this UniaxialMaterial. The method {\em getStrain()} is pure
virtual, while {\em getStrainRate()} is only virtual; by default it returns $0.0$, but
may be overridden in subclasses.

The next method is {\em getStress()}, which is to return the current stress of this
UniaxialMaterial. The current stress is a function of the current strain, $\varepsilon$, and
the current strain rate, $\dot{\varepsilon}$,

\begin{equation}
 \sigma = \sigma(\varepsilon,\dot{\varepsilon}) \: .
\end{equation}

\noindent The {\em getStress()} method is pure virtual and must be implemented by subclasses
of UniaxialMaterial.

The current material tangent is returned by the next method, {\em getTangent()}. The material tangent
is the partial derivative of the material stress with respect to the current strain,

\begin{equation}
 D_t = \frac{\partial{\sigma}}{\partial{\varepsilon}} \: .
\end{equation}

\noindent The {\em getTangent()} is also pure virtual and must be implemented in all UniaxialMaterial
subclasses.

The {\em getDampTangent()} method is next, and is to return the current damping tangent, which is
the partial derivative of the current stress with respect to the current strain rate,

\begin{equation}
 \eta = \frac{\partial{\sigma}}{\partial{\dot{\varepsilon}}} \: .
\end{equation}

\noindent By default, this method returns $0.0$, and it may be overridden in subclasses of
UniaxialMaterial where there is strain rate dependence.

Finally, the {\em getSecant()} method is provided to return the material secant, which
is the current stress divided by the current strain,

\begin{equation}
 D_s = \frac{\sigma}{\varepsilon} \: .
\end{equation}

\noindent By default, this method simply returns the result of invoking {\em getTangent()}, and
may be overridden in UniaxialMaterial subclasses. Be careful when $\varepsilon$ is equal to
$0.0$!!

The next set of methods deal with possible path dependent behavior of UniaxialMaterial models.
All Material objects in OpenSees are responsible for keeping track of and updating their
own history variables. First, the method {\em commitState()} is invoked to inform a
UniaxialMaterial object that its current state is on the converged solution path and
its internal history variables should be updated accordingly. Next, the method
{\em revertToLastCommit()} is provided to let a UniaxialMaterial object know that it
should return to its last committed state at. Finally, {\em revertToStart()} informs the
UniaxialMaterial object to revert to its initial state, i.e., at the start of
the analysis. All three of these methods are pure virtual, and thus must be implemented
in all subclasses of UniaxialMaterial.

The {\em getCopy()} method is declared so a calling object, be it an Element, Fiber, or
another Material object, can obtain an exact copy of this UniaxialMaterial object. A pointer
to the new object is returned by this function, and the calling object is responsible for
deleting this dynamically allocated memory.

The final two methods, {\em setResponse()} and {\em getResponse()}, are declared for
recording UniaxialMaterial state information. These methods have default implementations
to record the material stress, strain, and tangent. These methods may be overridden, but
their implementation is now shown in this document.

\section{Example -- HardeningMaterial}
In this section, it is shown how the rate-independent uniaxial hardening material model
given in Simo \& Hughes, {\em Computational Inelasticity} (1998) is implemented in OpenSees.
First, the class implementation
is shown, followed by its inclusion in the TCL model builder.

\subsection{Class Implementation}
The HardeningMaterial class
interface is shown below. Here, the virtual keyword is removed from the method declarations
since this class provides concrete implementations for UniaxialMaterial interface.

Note, three additional methods not declared in the UniaxialMaterial interface,
{\em sendSelf()}, {\em recvSelf()}, and {\em Print()}, must be defined in implementations 
of UniaxialMaterial. These methods are inherited from higher level classes in the OpenSees
framework, particularly, TaggedObject and MovableObject. An explanation of these methods
is provided in what follows.

{\sf\small
\begin{verbatim}
#include <UniaxialMaterial.h>

class HardeningMaterial : public UniaxialMaterial
{
   public:
      HardeningMaterial(int tag, double E, double sigmaY, double Hiso, double Hkin);
      HardeningMaterial();
      ~HardeningMaterial();

      int setTrialStrain(double strain, double strainRate = 0.0); 
      double getStrain(void);          
      double getStress(void);
      double getTangent(void);
      double getSecant(void);

      int commitState(void);
      int revertToLastCommit(void);    
      int revertToStart(void);        

      UniaxialMaterial *getCopy(void);
    
      int sendSelf(int commitTag, Channel &theChannel);  
      int recvSelf(int commitTag, Channel &theChannel, 
                   FEM_ObjectBroker &theBroker);    
    
      void Print(ostream &s, int flag = 0);
    
   protected:
    
   private:
      // Material parameters
      double E;       // Elastic modulus
      double sigmaY;  // Yield stress
      double Hiso;    // Isotropic hardening modulus
      double Hkin;    // Kinematic hardening modulus
	
      // Trial state variables
      double Tstrain;         // Trial strain
      double Tstress;         // Trial stress
      double Ttangent;        // Trial tangent
      double TplasticStrain;  // Trial plastic strain
      double TbackStress;     // Trial back stress
      double Thardening;      // Trial internal hardening variable
	
      // Committed history variables
      double Cstrain;         // Committed strain
      double CplasticStrain;  // Committed plastic strain
      double CbackStress;     // Committed back stress;
      double Chardening;      // Committed internal hardening variable
};
\end{verbatim}
}

\noindent The first two methods defined for HardeningMaterial are the constructors. The
first constructor takes the material tag and the material parameters. The UniaxialMaterial
base class constructor is invoked with the arguments tag and MAT\_TAG\_Hardening, the class
tag defined in classTags.h. The material parameters for this object are intialized in
the initialization list
and the history variables are initialized by calling the methods {\em revertToStart()} and
{\em revertToLastCommit()}. The second constructor is a blank constructor used for parallel
processing and database programming.

{\sf\small
\begin{verbatim}
   HardeningMaterial::HardeningMaterial(int tag, double e, double s,
                        double hi, double hk)
   :UniaxialMaterial(tag,MAT_TAG_Hardening),
    E(e), sigmaY(s), Hiso(hi), Hkin(hk)
   {
      this->revertToStart();
      this->revertToLastCommit();
   }

   HardeningMaterial::HardeningMaterial()
   :UniaxialMaterial(0,MAT_TAG_Hardening),
    E(0.0), sigmaY(0.0), Hiso(0.0), Hkin(0.0)
   {
      this->revertToStart();
      this->revertToLastCommit();
   }
\end{verbatim}
}

\noindent The next method defined is the destructor, which does nothing since no memory
is dynamically allocated by a HardeningMaterial object.

{\sf\small
\begin{verbatim}
   HardeningMaterial::~HardeningMaterial()
   {
      // does nothing
   }
\end{verbatim}
}

\noindent The following methods deal with the material state determination. The return
mapping algorithm is coded in {\em setTrialStrain()}. The stress and tangent of this HardeningMaterial
object are computed in stored in the instance variables Tstress and Ttangent and returned
by the methods {\em getStress()} and {\em getTangent()} respectively. The {\em getSecant()} and {\em getStrain()}
methods are defined here as well.

{\sf\small
\begin{verbatim}
   int 
   HardeningMaterial::setTrialStrain(double strain, double strainRate)
   {
      // Set total strain
      Tstrain = strain;
    
      // Elastic trial stress
      Tstress = E * (Tstrain-CplasticStrain);
    
      // Compute trial stress relative to committed back stress
      double xsi = Tstress - CbackStress;

      // Compute yield criterion
      double f = fabs(xsi) - (sigmaY + Hiso*Chardening);
    
      // Elastic step ... no updates required
      if (f <= 0.0) {
         // Set trial tangent
         Ttangent = E;
      }
      // Plastic step ... perform return mapping algorithm
      else {
         // Compute consistency parameter
         double dGamma = f / (E+Hiso+Hkin);
   
         // Find sign of xsi
         int sign = (xsi < 0) ? -1 : 1;

         // Bring trial stress back to yield surface
         Tstress -= dGamma*E*sign;
	
         // Update plastic strain
         TplasticStrain = CplasticStrain + dGamma*sign;
	
         // Update back stress
         TbackStress = CbackStress + dGamma*Hkin*sign;
	
         // Update internal hardening variable
         Thardening = Chardening + dGamma;
	
         // Set trial tangent
         Ttangent = E*(Hkin+Hiso) / (E+Hkin+Hiso);
      }

      return 0;
   }

   double 
   HardeningMaterial::getStress(void)
   {
      return Tstress;
   }

   double 
   HardeningMaterial::getTangent(void)
   {
      return Ttangent;
   }

   double
   HardeningMaterial::getSecant (void)
   {
      if (Tstrain != 0.0)
         return Tstress/Tstrain;
      else
         return E;
   }

   double 
   HardeningMaterial::getStrain(void)
   {
      return Tstrain;
   }
\end{verbatim}
}

\noindent The next set of methods deal with the path dependent behavior of this
HardeningMaterial object. The method {\em commitState()} sets the committed history variables
to be their corresponding trial values. The trial values are set to their last committed
values in {\em revertToLastCommit()}, and all committed values are set to zero in {\em revertToStart()}.

{\sf\small
\begin{verbatim}
   int 
   HardeningMaterial::commitState(void)
   {
      // Commit trial state variables
      Cstrain = Tstrain;
      CplasticStrain = TplasticStrain;
      CbackStress = TbackStress;
      Chardening = Thardening;

      return 0;
   }

   int 
   HardeningMaterial::revertToLastCommit(void)
   {
      // Set trial state to last committed state
      Tstrain = Cstrain;
      TplasticStrain = CplasticStrain;
      TbackStress = CbackStress;
      Thardening = Chardening;

      // Recompute trial stress and trial tangent
      this->setTrialStrain(Cstrain);

      return 0;
   }

   int 
   HardeningMaterial::revertToStart(void)
   {
      // Reset committed state variables
      Cstrain = 0.0;
      CplasticStrain = 0.0;
      CbackStress = 0.0;
      Chardening = 0.0;

      // Reset the trial state
      this->revertToLastCommit();    
    
      return 0;
   }
\end{verbatim}
}

\noindent The {\em getCopy()} method is defined so this HardeningMaterial object can
provide a clone of itself to a calling object, be it an Element, Fiber, or other
Material object. The constructor is invoked to create a new object, then all
instance variables are copied to the new object. The calling object is responsible
for deleting this dynamically allocated memory.

{\sf\small
\begin{verbatim}
   UniaxialMaterial *
   HardeningMaterial::getCopy(void)
   {
      HardeningMaterial *theCopy = 
            new HardeningMaterial(this->getTag(), E, sigmaY, Hiso, Hkin);

      // Copy trial state variables
      theCopy->Tstrain = Tstrain;
      theCopy->Tstress = Tstress;
      theCopy->Ttangent = Ttangent;
      theCopy->TplasticStrain = TplasticStrain;
      theCopy->TbackStress = TbackStress;
      theCopy->Thardening = Thardening;
    
      // Copy committed state variables
      theCopy->Cstrain = Cstrain;
      theCopy->CplasticStrain = CplasticStrain;
      theCopy->CbackStress = CbackStress;
      theCopy->Chardening = Chardening;
    
      return theCopy;
   }
\end{verbatim}
}

\noindent The next two methods are defined for parallel processing and database programming,
and are inherited from MovableObject.
The first method, {\em sendSelf()}, packs the material properties and committed history variables
in a Vector, then sends the Vector across the Channel object passed as an argument to the
method. The second method, {\em recvSelf()}, receives data from the Channel object, then populates
the data of this HardeningMaterial object with the received data.

{\sf\small
\begin{verbatim}
   int 
   HardeningMaterial::sendSelf(int cTag, Channel &theChannel)
   {
      int res = 0;
  
      static Vector data(9);
  
      data(0) = this->getTag();
      data(1) = E;
      data(2) = sigmaY;
      data(3) = Hiso;
      data(4) = Hkin;
      data(5) = Cstrain;
      data(6) = CplasticStrain;
      data(7) = CbackStress;
      data(8) = Chardening;
  
      res = theChannel.sendVector(this->getDbTag(), cTag, data);
      if (res < 0) 
         cerr << "HardeningMaterial::sendSelf() - failed to send data\n";

      return res;
   }

   int 
   HardeningMaterial::recvSelf(int cTag, Channel &theChannel, 
	               FEM_ObjectBroker &theBroker)
   {
      int res = 0;
  
      static Vector data(9);
      res = theChannel.recvVector(this->getDbTag(), cTag, data);
  
      if (res < 0) {
         cerr << "HardeningMaterial::recvSelf() - failed to receive data\n";
         this->setTag(0);      
      }
      else {
         this->setTag((int)data(0));
         E = data(1);
         sigmaY = data(2);
         Hiso = data(3);
         Hkin = data(4);
         Cstrain = data(5);
         CplasticStrain = data(6);
         CbackStress = data(7);
         Chardening = data(8);

         // Set the trial state variables
         revertToLastCommit();
      }
    
      return res;
   }
\end{verbatim}
}

\noindent The final HardeningMaterial method is {\em Print()}, which writes the material
name, tag, and parameters to the output stream passed as an argument. This method is
inherited from TaggedObject.

{\sf\small
\begin{verbatim}
   void 
   HardeningMaterial::Print(ostream &s, int flag)
   {
      s << "HardeningMaterial, tag: " << this->getTag() << endl;
      s << "  E: " << E << endl;
      s << "  sigmaY: " << sigmaY << endl;
      s << "  Hiso: " << Hiso << endl;
      s << "  Hkin: " << Hkin << endl;
   }
\end{verbatim}
}

\subsection{TCL Model Builder}
To add the new HardeningMaterial model to the OpenSees TCL model builder, the following snippet
of code needs to be added to the file TclModelBuilderUniaxialMaterialCommand.cpp. In this file
there are multiple if/else statements, one for each UniaxialMaterial that can be added to the model builder.
To add the new model only requires adding an additional case with the accompanying code to parse
the TCL command line.

The general form of the UniaxialMaterial command is as follows:

{\sf\small
\begin{verbatim}
   uniaxialMaterial materialType tag <specific material parameters>
\end{verbatim}
}

\noindent The above command is split into an array of character strings (argv) by TCL, then
sent to the function defined in TclModelBuilderUniaxialMaterialCommand.cpp. So, argv[0]
contains the command name ``uniaxialMaterial'', argv[1] holds the material keyword, argv[2]
contains the material tag, and the remaining entries in the argv array hold the specific
material parameters. These parameters are the arguments needed to call the appropriate
material constructor. The number of elements in the argv array is stored in the variable argc.

{\sf\small
\begin{verbatim}
int
TclModelBuilderUniaxialMaterialCommand(ClientData clienData, Tcl_Interp *interp,
                                       int argc, char **argv,
                                       TclModelBuilder *theTclBuilder)
{

   // Pointer to a UniaxialMaterial that will be added to the model builder
   UniaxialMaterial *theMaterial = 0;

   //
   // Additional code not shown
   //

   else if (strcmp(argv[1],"Hardening") == 0) {
      if (argc < 7) {
         cerr << "WARNING insufficient arguments\n";
         printCommand(argc,argv);
         cerr << "Want: uniaxialMaterial Hardening tag E sigmaY Hiso Hkin" << endl;
         return TCL_ERROR;
      }

      int tag;
      double E, sigmaY, Hiso, Hkin;

      if (Tcl_GetInt(interp, argv[2], &tag) != TCL_OK) {
         cerr << "WARNING invalid uniaxialMaterial Hardening tag" << endl;
         return TCL_ERROR;		
      }

      if (Tcl_GetDouble(interp, argv[3], &E) != TCL_OK) {
         cerr << "WARNING invalid E\n";
         cerr << "uniaxialMaterial Hardening: " << tag << endl;
         return TCL_ERROR;	
      }

      if (Tcl_GetDouble(interp, argv[4], &sigmaY) != TCL_OK) {
         cerr << "WARNING invalid sigmaY\n";
         cerr << "uniaxialMaterial Hardening: " << tag << endl;
         return TCL_ERROR;
      }

      if (Tcl_GetDouble(interp, argv[5], &Hiso) != TCL_OK) {
         cerr << "WARNING invalid Hiso\n";
         cerr << "uniaxialMaterial Hardening: " << tag << endl;
         return TCL_ERROR;	
      }

      if (Tcl_GetDouble(interp, argv[6], &Hkin) != TCL_OK) {
         cerr << "WARNING invalid Hkin\n";
         cerr << "uniaxialMaterial Hardening: " << tag << endl;
         return TCL_ERROR;	
      }

      // Parsing was successful, allocate the material
      theMaterial = new HardeningMaterial(tag, E, sigmaY, Hiso, Hkin);       
   }

   //
   // Additional code not shown
   //

   // Now add the material to the modelBuilder
   if (theTclBuilder->addUniaxialMaterial(*theMaterial) < 0) {
      cerr << "WARNING could not add uniaxialMaterial to the domain\n";
      cerr << *theMaterial << endl;
      delete theMaterial; // invoke the material objects destructor,
                          // otherwise memory leak
      return TCL_ERROR;
   }

   return TCL_OK;
}
\end{verbatim}
}

\noindent Once the UniaxialMaterial has been allocated, it is added to the model builder
at the end of the TclModelBuilderUniaxialMaterialCommand function, after the
multiple if/else statement has ended.

\section{Linking OpenSees with Other Material Interfaces}
Implementations of UniaxialMaterial hide their implementation details from calling
objects, i.e., calling objects only see the public interface defined in the UniaxialMaterial
base class. How the interface is implemented is encapsulated within each implementation
of the UniaxialMaterial interface. Thus, a particular implementation need not be written
in C++ as long as the implementation conforms to the interface, an example of which is
presented in this section. This example shows how the FEDEAS uniaxial material subroutine
interface, developed by F.C. Filippou is linked with OpenSees.

\subsection{FEDEAS subroutine interface}
The subroutine interface defined for a FEDEAS uniaxial material model named ``ML1D''
is shown below.

{\sf\small
\begin{verbatim}
subroutine ML1D(matpar,hstvP,hstv,epsP,sigP,deps,sig,tang,ist)
\end{verbatim}
}

\noindent The subroutine arguments are given as follows:

\begin{enumerate}
\item{matpar} - a double array of material parameters (in)
\item{hstvP} - a double array of committed history variables (in)
\item{hstv} - a double array of trial history variables (out)
\item{epsP} - strain at the last committed state (in)
\item{sigP} - stress at the last committed state (in)
\item{deps} - change in strain from the last committed state (in)
\item{sig} - the stress at the current trial state (out)
\item{tang} - the tangent at the current trial state (out)
\item{ist} - integer indicating the operation to be performed (in): 0 - return number
of material parameters and history variables, 1 - compute stress and tangent, 2 - compute 
stress and secant
\end{enumerate}

\subsection{FedeasMaterial Implementation in OpenSees}
This section presents an implementation of UniaxialMaterial capable of wrapping any
FORTRAN subroutine that conforms to the FEDEAS interface described in the previous
section. This implementation, FedeasMaterial, manages the data arrays sent to the
FEDEAS subroutine, i.e., FedeasMaterial is responsible for storing the material
parameters and history variables, as well as for swapping trial and committed history
variables.

FedeasMaterial is a base class whose subclasses, the specific FEDEAS uniaxial material models, 
are responsible for populating the material parameter array and for determining the number 
of history variables. All state determination and swapping of history variables is done
in the base class, FedeasMaterial, since it is a task common to all of its subclasses.

Private data is declared in FedeasMaterial to store history variables and material parameters.
First, hstv is a double array of size 2*numHV, where numHV is the number of history variables
needed for this FedeasMaterial object. Note that committed history variables are stored in the
first half of the hstv array, while the trial values are kept in the second half.
Next, data is a double array of size numData, the number
of material parameters for this object. The integer matType indicates which FORTRAN subroutine
to invoke during material state determination. The values epsilonP and sigmaP are the committed
strain and stress, respectively, of this material object, and are required for the FEDEAS subroutine
interface. Finally, three trial state variables, epsilon, sigma, and tangent are defined and 
returned by the methods {\em getStrain()}, {\em getStress()}, and {\em getTangent()}, respectively.

{\sf\small
\begin{verbatim}
   class FedeasMaterial : public UniaxialMaterial
   {
      public:
         FedeasMaterial(int tag, int classTag, int type, int numHV, int numData);
         FedeasMaterial(int classTag);
         virtual ~FedeasMaterial();

         virtual int setTrialStrain(double strain, double strainRate = 0.0);
         virtual double getStrain(void);
         virtual double getStress(void);
         virtual double getTangent(void);
         virtual double getSecant(void);

         virtual int commitState(void);
         virtual int revertToLastCommit(void);    
         virtual int revertToStart(void);        

         virtual UniaxialMaterial *getCopy(void);

         virtual int sendSelf(int commitTag, Channel &theChannel);  
         virtual int recvSelf(int commitTag, Channel &theChannel, 
		                      FEM_ObjectBroker &theBroker);    
    
         virtual void Print(ostream &s, int flag = 0);

      protected:
         virtual int invokeSubroutine(int ist); // Invokes the FEDEAS subroutine

         Vector *dataVec;  // Data vector populated by subclasses

      private:
         double *hstv;     // History array: first half is committed,
                           // second half is trial
         double *data;     // Material parameters array

         int matType;      // Material type ... tells which subroutine to call
         int numHV;        // Number of history variables
         int numData;      // Number of material parameters

         double epsilonP;  // Committed strain
         double sigmaP;    // Committed stress

         double epsilon;   // Trial strain
         double sigma;     // Trial stress
         double tangent;   // Trial tangent
   };
\end{verbatim}
}

\noindent The FedeasMaterial constructor initializes the private data with the
constructor arguments. The UniaxialMaterial base class constructor is invoked with the 
tag and classTag arguments. Then, the history variable and material parameter arrays
are allocated. A blank constructor is also defined on FedeasMaterial for parallel
processing and database programming.

{\sf\small
\begin{verbatim}
   FedeasMaterial::FedeasMaterial(int tag, int classTag, int type,
                                  int nhv, int ndata)
   :UniaxialMaterial(tag,classTag), dataVec(0), hstv(0), data(0), matType(type),
   numHV(nhv), numData(ndata), epsilonP(0.0), sigmaP(0.0),
   epsilon(0.0), sigma(0.0), tangent(0.0)
   {
      if (numHV < 0)
         numHV = 0;

      if (numHV > 0) {
         // Allocate history array
         hstv = new double[2*numHV];
         if (hstv == 0)
            g3ErrorHandler->fatal("%s -- failed to allocate history array -- type %d",
                                  "FedeasMaterial::FedeasMaterial", matType);
		
          // Zero out the history variables
          for (int i = 0; i < 2*numHV; i++)
             hstv[i] = 0.0;
      }

      if (numData < 0)
         numData = 0;

      if (numData > 0) {
         // Allocate material parameter array
         data = new double[numData];
         if (data == 0)
            g3ErrorHandler->fatal("%s -- failed to allocate data array -- type %d",
                                  "FedeasMaterial::FedeasMaterial", matType);

         // Allocate data vector to be populated in subclass constructor
         dataVec = new Vector(data, numData);
      }
   }

   FedeasMaterial::FedeasMaterial(int classTag)
   :UniaxialMaterial(0,classTag), dataVec(0), hstv(0), data(0), matType(0),
   numHV(0), numData(0), epsilonP(0.0), sigmaP(0.0),
   epsilon(0.0), sigma(0.0), tangent(0.0)
   {
      // Does nothing
   }
\end{verbatim}
}

\noindent The FedeasMaterial destructor deallocates the memory allocated in the constructor
to hold the history variables and material parameters.

{\sf\small
\begin{verbatim}
FedeasMaterial::~FedeasMaterial()
{
   if (hstv != 0)
      delete [] hstv;

   if (data != 0)
      delete [] data;

   if (dataVec != 0)
      delete dataVec;
}
\end{verbatim}
}

\noindent The next group of FedeasMaterial methods deal with the material state determination.
First, {\em setTrialStrain()} stores to trial strain, then invokes the FEDEAS subroutine with ist = 1,
indicating that normal stress and tangent quantities should be computed. The methods {\em getStrain()},
{\em getStress()}, and {\em getTangent()} return the strain, stress, and tangent of this FedeasMaterial.
Finally, {\em getSecant()} invokes the FEDEAS subroutine with ist = 2, for which a secant is computed.

{\sf\small
\begin{verbatim}
int
FedeasMaterial::setTrialStrain(double strain, double strainRate)
{
   // Store the strain
   epsilon = strain;

   // Tells subroutine to do normal operations for stress and tangent
   int ist = 1;

   // Call the subroutine
   return this->invokeSubroutine(ist);
}

double
FedeasMaterial::getStrain(void)
{
   return epsilon;
}

double
FedeasMaterial::getStress(void)
{
   return sigma;
}

double
FedeasMaterial::getTangent(void)
{
   return tangent;
}

double
FedeasMaterial::getSecant (void)
{
   // Same as ist = 1, but tells subroutine to return secant
   int ist = 2;

   this->invokeSubroutine(ist);

   return tangent;
}
\end{verbatim}
}

\noindent The next three methods deal with the path dependent behavior of this FedeasMaterial object.
The {\em commitState()} method copies the trial history variables from the second half of the
hstv array to the first half, where the committed values are stored. The committed values are
copies to the trial values in {\em revertToLastCommit()}, and all values are set to zero in the
{\em revertToStart()} method.

{\sf\small
\begin{verbatim}
int
FedeasMaterial::commitState(void)
{
   // Set committed values equal to corresponding trial values
   for (int i = 0; i < numHV; i++)
      hstv[i] = hstv[i+numHV];

   epsilonP = epsilon;
   sigmaP = sigma;

   return 0;
}

int
FedeasMaterial::revertToLastCommit(void)
{
   // Set trial values equal to corresponding committed values
   for (int i = 0; i < numHV; i++)
      hstv[i+numHV] = hstv[i];

   epsilon = epsilonP;
   sigma = sigmaP;

   return 0;
}

int
FedeasMaterial::revertToStart(void)
{
   // Set all trial and committed values to zero
   for (int i = 0; i < 2*numHV; i++)
      hstv[i] = 0.0;

   epsilonP = 0.0;
   sigmaP = 0.0;

   return 0;
}
\end{verbatim}
}

\noindent A copy of this FedeasMaterial object is returned by {\em getCopy()}. First, the
FedeasMaterial constructor is called with the necessary tag, type, and array size data.
Then, the committed strain and stress, all history variables, and material parameters
are copied to the new object before it is returned.

{\sf\small
\begin{verbatim}
UniaxialMaterial*
FedeasMaterial::getCopy(void)
{
   FedeasMaterial *theCopy = 
         new FedeasMaterial(this->getTag(), this->getClassTag(),
                            matType, numHV, numData);

   theCopy->epsilonP = epsilonP;
   theCopy->sigmaP = sigmaP;

   int i;
   for (i = 0; i < 2*numHV; i++)
      theCopy->hstv[i] = hstv[i];

   for (i = 0; i < numData; i++)
      theCopy->data[i] = data[i];

   return theCopy;
}
\end{verbatim}
}

\noindent The next two methods are defined for parallel processing and database programming.
The first method, {\em sendSelf()}, packs the tag and array size information for this FedeasMaterial
object into an ID vector and sends it across the Channel. Then, the material properties and 
committed history variables are put in a Vector, and sent as well.
The second method, {\em recvSelf()}, receives both the ID and Vector data from the Channel object, 
then populates the data of this FedeasMaterial object with the appropriate data.

{\sf\small
\begin{verbatim}
int 
FedeasMaterial::sendSelf(int commitTag, Channel &theChannel)
{
   int res = 0;

   static ID idData(3);

   idData(0) = this->getTag();
   idData(1) = numHV;
   idData(2) = numData;

   res += theChannel.sendID(this->getDbTag(), commitTag, idData);
   if (res < 0) 
      cerr << "FedeasMaterial::sendSelf() - failed to send ID data\n";

   Vector vecData(numHV+numData);

   int i, j;
   // Copy history variables into vector
   for (i = 0; i < numHV; i++)
      vecData(i) = hstv[i];

   // Copy material properties into vector
   for (i = 0, j = numHV; i < numData; i++, j++)
      vecData(j) = data[i];

   res += theChannel.sendVector(this->getDbTag(), commitTag, vecData);
   if (res < 0) 
      cerr << "FedeasMaterial::sendSelf() - failed to send Vector data\n";

   return res;
}

int
FedeasMaterial::recvSelf(int commitTag, Channel &theChannel,
							FEM_ObjectBroker &theBroker)
{
   int res = 0;

   static ID idData(3);

   res += theChannel.recvID(this->getDbTag(), commitTag, idData);
   if (res < 0) {
      cerr << "FedeasMaterial::recvSelf() - failed to receive ID data\n";
      return res;
   }

   this->setTag(idData(0));
   numHV = idData(1);
   numData = idData(2);

   Vector vecData(numHV+numData);

   res += theChannel.recvVector(this->getDbTag(), commitTag, vecData);
   if (res < 0) {
      cerr << "FedeasMaterial::recvSelf() - failed to receive Vector data\n";
      return res;
   }

   int i, j;
   // Copy history variables from vector
   for (i = 0; i < numHV; i++)
      hstv[i] = vecData(i);

   // Copy material properties from vector
   for (i = 0, j = numHV; i < numData; i++, j++)
      data[i] = vecData(j);

   return res;
}
\end{verbatim}
}

\noindent The {\em Print()} method outputs the name of this FedeasMaterial object, then prints
the material parameters to the stream passed as an argument. More cases can be added to
the switch statement as additional FORTRAN subroutines are added to OpenSees.
    
{\sf\small
\begin{verbatim}
void
FedeasMaterial::Print(ostream &s, int flag)
{
   s << "FedeasMaterial, type: ";
	
   switch (matType) {
   case FEDEAS_Hardening:
      s << "Hardening" << endl;
      break;

   // Add more cases as needed
   default:
      s << matType << endl;
      break;
   }
	
   s << "Data vector: " << *dataVec << endl;
}
\end{verbatim}
}

\noindent In order to link the FORTRAN subroutine with the OpenSees C++ libraries, the
following external function declarations are needed. There are two syntactic styles for
these declarations, one for Win32 and one for everything else. The preprocessor directives
put the proper declaration into the source code. Additional declarations may be added
as more subroutines are included in OpenSees.

{\sf\small
\begin{verbatim}
#ifdef _WIN32

extern "C" int _stdcall HARDENING(double *matpar, double *hstvP, double *hstv,
                                  double *strainP, double *stressP, double *dStrain,
                                  double *tangent, double *stress, int *ist);

#define hardening_   HARDENING

// Add more cases as needed

#else

extern "C" int hardening_(double *matpar, double *hstvP, double *hstv,
                          double *strainP, double *stressP, double *dStrain,
                          double *tangent, double *stress, int *ist);

// Add more cases as needed

#endif
\end{verbatim}
}

\noindent The method invokeSubroutine() calls the appropriate FEDEAS subroutine based
on the matType parameter. The FedeasMaterial instance variables are passed to the
FORTRAN subroutine from this method. Additional cases in the switch statement can
be added as more subroutines are linked with OpenSees.

{\sf\small
\begin{verbatim}
int
FedeasMaterial::invokeSubroutine(int ist)
{
   // Compute strain increment
   double dEpsilon = epsilon-epsilonP;

   switch (matType) {
   case FEDEAS_Hardeneing:
      hardening_(data, hstv, &hstv[numHV], &epsilonP, &sigmaP, &dEpsilon, 
                 &sigma, &tangent, &ist);
      break;

   // Add more cases as needed
   default:
      g3ErrorHandler->fatal("%s -- unknown material type",
                            "FedeasMaterial::invokeSubroutine");
      return -1;
   }

   return 0;
}
\end{verbatim}
}

\subsection{Example -- FedeasHardeningMaterial}
The material data array defined in FedeasMaterial is populated by its subclass
FedeasHardeningMaterial. This is the only functionality defined for FedeasMaterial
subclasses. All state determination and swapping of history variables is handled
by the methods defined in the base class FedeasMaterial, as described above.

In this example, the FedeasHardeningMaterial constructor populates the data vector
and invokes the FedeasMaterial constructor with the number of history variables and
number of material parameters. The blank constructor and destructor do nothing.

As additional FEDEAS subroutines are added to OpenSees, new subclasses of FedeasMaterial
must be added in order to populate the data array. This is all that need
be done in the derived class as the base class, FedeasMaterial, contains all the 
computational code and keeps track of path dependent behavior. This functionality is
inherited from the FedeasMaterial base class. However, the base class 
must be modified such that the appropriate
subroutine is called during state determination from the method invokeSubroutine().

\subsubsection*{FedeasHardeningMaterial Subclass}
{\sf\small
\begin{verbatim}
class FedeasHardeningMaterial : public FedeasMaterial
{
   public:
      FedeasHardeningMaterial(int tag, double E, double sigmaY,
                              double Hiso, double Hkin);
      FedeasHardeningMaterial(void);
      ~FedeasHardeningMaterial();

   protected:

   private:
};


FedeasHardeningMaterial::FedeasHardeningMaterial(int tag,
                            double E, double sigmaY, double Hiso, double Hkin):
// 3 history variables and 4 material parameters
FedeasMaterial(tag, FEDEAS_TAG_Hardening, FEDEAS_Hardening, 3, 4)
{
   (*dataVec)(0)  = E;
   (*dataVec)(1)  = sigmaY;
   (*dataVec)(2)  = Hiso;
   (*dataVec)(3)  = Hkin;
}

FedeasHardeningMaterial::FedeasHardeningMaterial(void):
FedeasMaterial(FEDEAS_TAG_Hardening)
{
   // Does nothing
}

FedeasHardeningMaterial::~FedeasHardeningMaterial(void)
{
   // Does nothing
}
\end{verbatim}
}

\subsubsection*{FEDEAS Hardening Subroutine}
This section contains the implementation of the uniaxial hardening material coded as a
FORTRAN subroutine using the FEDEAS interface. The subroutine declares local variables
to store the material parameters passed through the matpar array. The committed history
variables are received from hstvP, and the trial history variables are written to hstv
upon return. The trial stress and tangent are also set upon return in the variables
sig and tang.

{\sf\small
\begin{verbatim}
subroutine Hardening(matpar,hstvP,hstv,epsP,sigP,deps,sig,tang,ist)

implicit none
 
! Arguments
integer ist
real*8  matpar(4),hstvP(3),hstv(3)
real*8  epsP,sigP,deps
real*8  sig,tang

! Local variables
real*8  E,sigY,Hiso,Hkin
real*8  ep,alpha,kappa   
real*8  eps,f,xsi,dGamma
integer sgn

! Material parameters
E    = matpar(1)
sigY = matpar(2)
Hiso = matpar(3)
Hkin = matpar(4)

! History variables
ep    = hstvP(1)
alpha = hstvP(2)
kappa = hstvP(3)

! Current strain
eps = epsP + deps    

! Elastic predictor
sig = E * (eps - ep)

! Stress relative to back stress
xsi = sig - kappa

! Yield function
f = dabs(xsi) - (sigY + Hiso*alpha)

! Inside yield surface
if (f <= 0.0) then
   tang = E
! Outside yield surface ... do return mapping
else
   ! Consistency parameter
   dGamma = f / (E+Hiso+Hkin)

   ! Normal to yield surface
   if (xsi <= 0.d0) then
      sgn = -1
   else
      sgn = 1
   endif

   ! Updated stress
   sig = sig - dGamma*E*sgn
	
   ! Updated plastic strain
   ep = ep + dGamma*sgn

   ! Updated back stress
   kappa = kappa + dGamma*Hkin*sgn
	
   ! Updated internal hardening variable
   alpha = alpha + dGamma

   ! Elasto-plastic tangent
   tang = E*(Hkin+Hiso) / (E+Hkin+Hiso)
endif

! Update history variables
hstv(1) = ep
hstv(2) = alpha
hstv(3) = kappa

return

end subroutine Hardening\end{verbatim}
}

Adding the FedeasHardeningMaterial model to the TCL model builder is done in exactly the same
manner as for HardeningMaterial since both models have the same material parameters. Only the
material allocation would change. The following line in TclModelBuilderUniaxialMaterialCommand.cpp

{\sf\small
\begin{verbatim}
      // Parsing was successful, allocate the material
      theMaterial = new HardeningMaterial(tag, E, sigmaY, Hiso, Hkin); 
\end{verbatim}
}

\noindent would be replaced with

{\sf\small
\begin{verbatim}
      // Parsing was successful, allocate the material
      theMaterial = new FedeasHardeningMaterial(tag, E, sigmaY, Hiso, Hkin); 
\end{verbatim}
}

\noindent after reading in the material parameters.

\end{document}
